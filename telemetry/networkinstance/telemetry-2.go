package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Await(t testing.TB, timeout time.Duration, val oc.E_Mpls_CspfTieBreaking) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_METRIC_TYPE) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath extracts the value of the leaf SpfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath extracts the value of the leaf ExcludeGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExcludeGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath extracts the value of the leaf IncludeAllGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAllGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath extracts the value of the leaf IncludeAnyGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAnyGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Lookup(t testing.TB) *oc.QualifiedUint64Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Get(t testing.TB) []uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Get(t testing.TB) [][]uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	w := &oc.Uint64SliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Await(t testing.TB, timeout time.Duration, val []uint64) *oc.QualifiedUint64Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath extracts the value of the leaf AssociatedRsvpSessions from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64Slice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64Slice {
	t.Helper()
	qv := &oc.QualifiedUint64Slice{
		Metadata: md,
	}
	val := parent.AssociatedRsvpSessions
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath extracts the value of the leaf CspfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.CspfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Await(t testing.TB, timeout time.Duration, val oc.E_Mpls_CspfTieBreaking) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_METRIC_TYPE) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath extracts the value of the leaf SpfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetProtectionStyleRequested())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath extracts the value of the leaf ProtectionStyleRequested from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.ProtectionStyleRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath extracts the value of the leaf ReoptimizeTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReoptimizeTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Get(t testing.TB) oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_ROLE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_ROLE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_ROLE) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath extracts the value of the leaf Role from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_ROLE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_ROLE{
		Metadata: md,
	}
	val := parent.Role
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetShortcutEligible())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath extracts the value of the leaf ShortcutEligible from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ShortcutEligible
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Get(t testing.TB) oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_SETUP_PROTOCOL
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath extracts the value of the leaf SignalingProtocol from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL{
		Metadata: md,
	}
	val := parent.SignalingProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSoftPreemption())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath extracts the value of the leaf SoftPreemption from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SoftPreemption
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Get(t testing.TB) oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_TUNNEL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_TUNNEL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_TUNNEL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_TUNNEL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_TUNNEL_TYPE) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_TUNNEL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_TUNNEL_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_TUNNEL_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLspPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocolsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocolsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocolsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocolsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_LdpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_LdpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_LdpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath extracts the value of the leaf ForwardingHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ForwardingHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath extracts the value of the leaf HelperEnable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HelperEnable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath extracts the value of the leaf ReconnectTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReconnectTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath extracts the value of the leaf RecoveryTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RecoveryTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath extracts the value of the leaf LsrId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LsrId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAfi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAfi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAfi) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAfi.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAfi{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAdjacencyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAdjacencyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAdjacencyType) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAdjacencyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath extracts the value of the leaf AdjacencyType from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType{
		Metadata: md,
	}
	val := parent.AdjacencyType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath extracts the value of the leaf HelloDropped from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloDropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath extracts the value of the leaf Adjacent from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Adjacent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath extracts the value of the leaf HelloExpiration from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloExpiration
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath extracts the value of the leaf Negotiated from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Negotiated
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath extracts the value of the leaf NextHello from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHello
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath extracts the value of the leaf HelloReceived from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloReceived
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath extracts the value of the leaf LastClear from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LastClear
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath extracts the value of the leaf LocalAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath extracts the value of the leaf RemoteAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath extracts the value of the leaf LabelSpaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LabelSpaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath extracts the value of the leaf LsrId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LsrId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Get(t testing.TB) oc.E_MplsLdp_Neighbor_SessionState {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_Neighbor_SessionState
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Get(t testing.TB) []oc.E_MplsLdp_Neighbor_SessionState {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_Neighbor_SessionState
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_Neighbor_SessionState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_Neighbor_SessionStateWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_Neighbor_SessionState)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_Neighbor_SessionState) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_Neighbor_SessionState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath extracts the value of the leaf SessionState from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_Neighbor_SessionState.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_Neighbor_SessionState{
		Metadata: md,
	}
	val := parent.SessionState
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAfi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAfi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAfi) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAfi.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAfi{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath extracts the value of the leaf LocalAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath extracts the value of the leaf RemoteAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath extracts the value of the leaf HelloAccept from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HelloAccept
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath extracts the value of the leaf AuthenticationFail from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AuthenticationFail
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath extracts the value of the leaf BadChecksum from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadChecksum
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath extracts the value of the leaf BadPacketFormat from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketFormat
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath extracts the value of the leaf BadPacketLength from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath extracts the value of the leaf OutOfOrder from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOfOrder
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath extracts the value of the leaf ReceivedNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReceivedNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath extracts the value of the leaf TransmitFailure from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitFailure
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath extracts the value of the leaf TransmitQueueFull from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitQueueFull
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath extracts the value of the leaf UnknownAck from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownAck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath extracts the value of the leaf UnknownNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath extracts the value of the leaf InAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath extracts the value of the leaf InHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath extracts the value of the leaf InPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath extracts the value of the leaf InPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath extracts the value of the leaf InPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath extracts the value of the leaf InReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}
