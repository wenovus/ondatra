package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath extracts the value of the leaf InReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath extracts the value of the leaf InReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath extracts the value of the leaf InSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath extracts the value of the leaf OutAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath extracts the value of the leaf OutHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath extracts the value of the leaf OutPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath extracts the value of the leaf OutPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath extracts the value of the leaf OutPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath extracts the value of the leaf OutReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath extracts the value of the leaf OutReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath extracts the value of the leaf OutReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath extracts the value of the leaf OutSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath extracts the value of the leaf PathTimeouts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PathTimeouts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath extracts the value of the leaf RateLimitedMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.RateLimitedMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath extracts the value of the leaf ReservationTimeouts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReservationTimeouts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath extracts the value of the leaf RecoveryTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.RecoveryTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath extracts the value of the leaf RestartTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.RestartTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetHelloInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRefreshReduction())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetSoftPreemptionTimeout())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath extracts the value of the leaf SoftPreemptionTimeout from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SoftPreemptionTimeout
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath extracts the value of the leaf ActiveReservationsCount from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ActiveReservationsCount
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath extracts the value of the leaf AvailableBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AvailableBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath extracts the value of the leaf HighwaterMark from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HighwaterMark
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath extracts the value of the leaf ReservedBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReservedBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath extracts the value of the leaf AuthenticationFail from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AuthenticationFail
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath extracts the value of the leaf BadChecksum from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadChecksum
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath extracts the value of the leaf BadPacketFormat from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketFormat
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath extracts the value of the leaf BadPacketLength from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath extracts the value of the leaf OutOfOrder from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOfOrder
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath extracts the value of the leaf ReceivedNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReceivedNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath extracts the value of the leaf TransmitFailure from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitFailure
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath extracts the value of the leaf TransmitQueueFull from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitQueueFull
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath extracts the value of the leaf UnknownAck from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownAck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath extracts the value of the leaf UnknownNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath extracts the value of the leaf InAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath extracts the value of the leaf InHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath extracts the value of the leaf InPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath extracts the value of the leaf InPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath extracts the value of the leaf InPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath extracts the value of the leaf InReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath extracts the value of the leaf InReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath extracts the value of the leaf InReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath extracts the value of the leaf InSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath extracts the value of the leaf OutAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath extracts the value of the leaf OutHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath extracts the value of the leaf OutPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath extracts the value of the leaf OutPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath extracts the value of the leaf OutPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath extracts the value of the leaf OutReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath extracts the value of the leaf OutReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath extracts the value of the leaf OutReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath extracts the value of the leaf OutSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath extracts the value of the leaf RateLimitedMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.RateLimitedMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetHelloInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRefreshReduction())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath extracts the value of the leaf MaxLinkBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MaxLinkBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath extracts the value of the leaf BypassOptimizeInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.BypassOptimizeInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetLinkProtectionStyleRequested())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath extracts the value of the leaf LinkProtectionStyleRequested from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.LinkProtectionStyleRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath extracts the value of the leaf CalculatedAbsoluteSubscriptionBw from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.CalculatedAbsoluteSubscriptionBw
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath extracts the value of the leaf Subscription from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Subscription
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath extracts the value of the leaf DetectedInterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DetectedInterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Lookup(t testing.TB) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Get(t testing.TB) oc.E_Neighbor_NeighborStatus {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Neighbor_NeighborStatus
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Get(t testing.TB) []oc.E_Neighbor_NeighborStatus {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Neighbor_NeighborStatus
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Neighbor_NeighborStatus {
	t.Helper()
	c := &oc.CollectionE_Neighbor_NeighborStatus{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	w := &oc.E_Neighbor_NeighborStatusWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Neighbor_NeighborStatus)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Await(t testing.TB, timeout time.Duration, val oc.E_Neighbor_NeighborStatus) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Neighbor_NeighborStatus {
	t.Helper()
	c := &oc.CollectionE_Neighbor_NeighborStatus{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath extracts the value of the leaf NeighborStatus from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Neighbor_NeighborStatus.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	qv := &oc.QualifiedE_Neighbor_NeighborStatus{
		Metadata: md,
	}
	val := parent.NeighborStatus
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath extracts the value of the leaf DestinationAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DestinationAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath extracts the value of the leaf Asn from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Asn
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath extracts the value of the leaf IpPrefix from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.IpPrefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath extracts the value of the leaf Label from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{
		Metadata: md,
	}
	val := parent.Label
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath extracts the value of the leaf Loose from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Loose
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Lookup(t testing.TB) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Get(t testing.TB) oc.E_ExplicitRouteObject_Type {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_ExplicitRouteObject_Type
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Get(t testing.TB) []oc.E_ExplicitRouteObject_Type {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_ExplicitRouteObject_Type
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_ExplicitRouteObject_Type {
	t.Helper()
	c := &oc.CollectionE_ExplicitRouteObject_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	w := &oc.E_ExplicitRouteObject_TypeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_ExplicitRouteObject_Type)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_ExplicitRouteObject_Type) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_ExplicitRouteObject_Type {
	t.Helper()
	c := &oc.CollectionE_ExplicitRouteObject_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedE_ExplicitRouteObject_Type.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	qv := &oc.QualifiedE_ExplicitRouteObject_Type{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath extracts the value of the leaf LabelIn from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{
		Metadata: md,
	}
	val := parent.LabelIn
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath extracts the value of the leaf LabelOut from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{
		Metadata: md,
	}
	val := parent.LabelOut
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath extracts the value of the leaf LocalIndex from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LocalIndex
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath extracts the value of the leaf LspId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LspId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath extracts the value of the leaf ProtectionRequested from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.ProtectionRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath extracts the value of the leaf ReportedFlags from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.ReportedFlags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath extracts the value of the leaf ReportedLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{
		Metadata: md,
	}
	val := parent.ReportedLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath extracts the value of the leaf PeakDataRate from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.PeakDataRate
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath extracts the value of the leaf Rate from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Rate
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath extracts the value of the leaf Size from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Size
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath extracts the value of the leaf SessionName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SessionName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath extracts the value of the leaf SourceAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SourceAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Lookup(t testing.TB) *oc.QualifiedE_Session_Status {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Get(t testing.TB) oc.E_Session_Status {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Session_Status {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Session_Status
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Get(t testing.TB) []oc.E_Session_Status {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Session_Status
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Session_Status {
	t.Helper()
	c := &oc.CollectionE_Session_Status{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Session_Status) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	w := &oc.E_Session_StatusWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Session_Status)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Await(t testing.TB, timeout time.Duration, val oc.E_Session_Status) *oc.QualifiedE_Session_Status {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Session_Status) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Session_Status {
	t.Helper()
	c := &oc.CollectionE_Session_Status{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Session_Status) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath extracts the value of the leaf Status from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Session_Status.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_Session_Status {
	t.Helper()
	qv := &oc.QualifiedE_Session_Status{
		Metadata: md,
	}
	val := parent.Status
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath extracts the value of the leaf TunnelId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.TunnelId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Get(t testing.TB) oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_ROLE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_ROLE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_ROLE) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_ROLE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_ROLE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath extracts the value of the leaf MplsLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{
		Metadata: md,
	}
	val := parent.MplsLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath extracts the value of the leaf Exp from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Exp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath extracts the value of the leaf MplsLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{
		Metadata: md,
	}
	val := parent.MplsLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}
