package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_SubtlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_AdjacencySid_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Get(t testing.TB) []oc.E_AdjacencySid_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_AdjacencySid_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_AdjacencySid_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPathAny) Get(t testing.TB) [][]oc.E_AdjacencySid_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_AdjacencySid_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AdjacencySid_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_AdjacencySid_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AdjacencySid_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_AdjacencySid_FlagsSlice) bool) *oc.E_AdjacencySid_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_AdjacencySid_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_AdjacencySid_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AdjacencySid_FlagsSlice) bool) *oc.E_AdjacencySid_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_AdjacencySid_Flags) *oc.QualifiedE_AdjacencySid_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_AdjacencySid_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AdjacencySid_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_AdjacencySid_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AdjacencySid_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AdjacencySid_FlagsSlice) bool) *oc.E_AdjacencySid_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedE_AdjacencySid_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) *oc.QualifiedE_AdjacencySid_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_AdjacencySid_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath extracts the value of the leaf Weight from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid_WeightPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Weight
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Lookup(t testing.TB) *oc.QualifiedUint32Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Get(t testing.TB) []uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPathAny) Get(t testing.TB) [][]uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32Slice {
	t.Helper()
	c := &oc.CollectionUint32Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	w := &oc.Uint32SliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Await(t testing.TB, timeout time.Duration, val []uint32) *oc.QualifiedUint32Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32Slice {
	t.Helper()
	c := &oc.CollectionUint32Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group/state/admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath extracts the value of the leaf AdminGroup from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32Slice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup_AdminGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) *oc.QualifiedUint32Slice {
	t.Helper()
	qv := &oc.QualifiedUint32Slice{
		Metadata: md,
	}
	val := parent.AdminGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint/state/constraint-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath extracts the value of the leaf ConstraintId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint_ConstraintIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ConstraintId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/state/model-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath extracts the value of the leaf ModelId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_ModelIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.ModelId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Lookup(t testing.TB) *oc.QualifiedUint32Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Get(t testing.TB) []uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPathAny) Get(t testing.TB) [][]uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32Slice {
	t.Helper()
	c := &oc.CollectionUint32Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	w := &oc.Uint32SliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Await(t testing.TB, timeout time.Duration, val []uint32) *oc.QualifiedUint32Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32Slice {
	t.Helper()
	c := &oc.CollectionUint32Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32Slice) bool) *oc.Uint32SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group/state/extended-admin-group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath extracts the value of the leaf ExtendedAdminGroup from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32Slice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup_ExtendedAdminGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) *oc.QualifiedUint32Slice {
	t.Helper()
	qv := &oc.QualifiedUint32Slice{
		Metadata: md,
	}
	val := parent.ExtendedAdminGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Get(t testing.TB) []oc.E_LanAdjacencySid_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_LanAdjacencySid_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPathAny) Get(t testing.TB) [][]oc.E_LanAdjacencySid_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_LanAdjacencySid_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_LanAdjacencySid_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool) *oc.E_LanAdjacencySid_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_LanAdjacencySid_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_LanAdjacencySid_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool) *oc.E_LanAdjacencySid_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_LanAdjacencySid_Flags) *oc.QualifiedE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_LanAdjacencySid_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LanAdjacencySid_FlagsSlice) bool) *oc.E_LanAdjacencySid_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedE_LanAdjacencySid_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) *oc.QualifiedE_LanAdjacencySid_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_LanAdjacencySid_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/neighbor-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath extracts the value of the leaf NeighborId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_NeighborIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NeighborId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath extracts the value of the leaf Weight from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid_WeightPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Weight
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Lookup(t testing.TB) *oc.QualifiedE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Get(t testing.TB) []oc.E_LinkAttributes_LocalProtection {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPathAny) Lookup(t testing.TB) []*oc.QualifiedE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_LinkAttributes_LocalProtectionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPathAny) Get(t testing.TB) [][]oc.E_LinkAttributes_LocalProtection {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_LinkAttributes_LocalProtection
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	c := &oc.CollectionE_LinkAttributes_LocalProtectionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool) *oc.E_LinkAttributes_LocalProtectionSliceWatcher {
	t.Helper()
	w := &oc.E_LinkAttributes_LocalProtectionSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_LinkAttributes_LocalProtectionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool) *oc.E_LinkAttributes_LocalProtectionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Await(t testing.TB, timeout time.Duration, val []oc.E_LinkAttributes_LocalProtection) *oc.QualifiedE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	c := &oc.CollectionE_LinkAttributes_LocalProtectionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LinkAttributes_LocalProtectionSlice) bool) *oc.E_LinkAttributes_LocalProtectionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes/state/local-protection to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath extracts the value of the leaf LocalProtection from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedE_LinkAttributes_LocalProtectionSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes_LocalProtectionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) *oc.QualifiedE_LinkAttributes_LocalProtectionSlice {
	t.Helper()
	qv := &oc.QualifiedE_LinkAttributes_LocalProtectionSlice{
		Metadata: md,
	}
	val := parent.LocalProtection
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath extracts the value of the leaf Delay from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation_DelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Delay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath extracts the value of the leaf ABit from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_ABitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ABit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath extracts the value of the leaf Delay from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay_DelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Delay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/local to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath extracts the value of the leaf Local from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_LocalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Local
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id/state/remote to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath extracts the value of the leaf Remote from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId_RemotePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Remote
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLossPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath extracts the value of the leaf ABit from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_ABitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ABit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss/state/link-loss to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath extracts the value of the leaf LinkLoss from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss_LinkLossPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.LinkLoss
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Lookup(t testing.TB) *oc.QualifiedE_LinkProtectionType_TypeSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Get(t testing.TB) []oc.E_LinkProtectionType_Type {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_LinkProtectionType_TypeSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_LinkProtectionType_TypeSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePathAny) Get(t testing.TB) [][]oc.E_LinkProtectionType_Type {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_LinkProtectionType_Type
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LinkProtectionType_TypeSlice {
	t.Helper()
	c := &oc.CollectionE_LinkProtectionType_TypeSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LinkProtectionType_TypeSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_LinkProtectionType_TypeSlice) bool) *oc.E_LinkProtectionType_TypeSliceWatcher {
	t.Helper()
	w := &oc.E_LinkProtectionType_TypeSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_LinkProtectionType_TypeSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LinkProtectionType_TypeSlice) bool) *oc.E_LinkProtectionType_TypeSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Await(t testing.TB, timeout time.Duration, val []oc.E_LinkProtectionType_Type) *oc.QualifiedE_LinkProtectionType_TypeSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_LinkProtectionType_TypeSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_LinkProtectionType_TypeSlice {
	t.Helper()
	c := &oc.CollectionE_LinkProtectionType_TypeSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_LinkProtectionType_TypeSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_LinkProtectionType_TypeSlice) bool) *oc.E_LinkProtectionType_TypeSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType
// and combines the update with an existing Metadata to return a *oc.QualifiedE_LinkProtectionType_TypeSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) *oc.QualifiedE_LinkProtectionType_TypeSlice {
	t.Helper()
	qv := &oc.QualifiedE_LinkProtectionType_TypeSlice{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/a-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath extracts the value of the leaf ABit from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_ABitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ABit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/max-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath extracts the value of the leaf MaxDelay from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MaxDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.MaxDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay/state/min-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath extracts the value of the leaf MinDelay from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay_MinDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.MinDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/te-default-metric/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/count to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath extracts the value of the leaf Count from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_CountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Count
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/unconstrained-lsp/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath extracts the value of the leaf Bandwidth from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_BandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Bandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/subtlvs/subtlv/utilized-bandwidth/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath extracts the value of the leaf Length from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_LengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Length
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/instances/instance/undefined-subtlvs/undefined-subtlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/mt-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath extracts the value of the leaf MtId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_MtIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.MtId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/mt-isn/neighbors/neighbor/state/system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath extracts the value of the leaf SystemId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_SystemIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SystemId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopologyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_TopologyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Lookup(t testing.TB) *oc.QualifiedE_Topology_Attributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Get(t testing.TB) oc.E_Topology_Attributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Topology_Attributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Topology_Attributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPathAny) Get(t testing.TB) []oc.E_Topology_Attributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Topology_Attributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Topology_Attributes {
	t.Helper()
	c := &oc.CollectionE_Topology_Attributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Topology_Attributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Topology_Attributes) bool) *oc.E_Topology_AttributesWatcher {
	t.Helper()
	w := &oc.E_Topology_AttributesWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Topology_Attributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Topology_Attributes) bool) *oc.E_Topology_AttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Await(t testing.TB, timeout time.Duration, val oc.E_Topology_Attributes) *oc.QualifiedE_Topology_Attributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Topology_Attributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Topology_Attributes {
	t.Helper()
	c := &oc.CollectionE_Topology_Attributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Topology_Attributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Topology_Attributes) bool) *oc.E_Topology_AttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/attributes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath extracts the value of the leaf Attributes from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Topology_Attributes.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_AttributesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) *oc.QualifiedE_Topology_Attributes {
	t.Helper()
	qv := &oc.QualifiedE_Topology_Attributes{
		Metadata: md,
	}
	val := parent.Attributes
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/multi-topology/topologies/topology/state/mt-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath extracts the value of the leaf MtId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology_MtIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.MtId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_NlpidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Lookup(t testing.TB) *oc.QualifiedE_Nlpid_NlpidSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Get(t testing.TB) []oc.E_Nlpid_Nlpid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Nlpid_NlpidSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Nlpid_NlpidSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPathAny) Get(t testing.TB) [][]oc.E_Nlpid_Nlpid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Nlpid_Nlpid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Nlpid_NlpidSlice {
	t.Helper()
	c := &oc.CollectionE_Nlpid_NlpidSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Nlpid_NlpidSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Nlpid_NlpidSlice) bool) *oc.E_Nlpid_NlpidSliceWatcher {
	t.Helper()
	w := &oc.E_Nlpid_NlpidSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Nlpid_NlpidSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Nlpid_NlpidSlice) bool) *oc.E_Nlpid_NlpidSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Nlpid_Nlpid) *oc.QualifiedE_Nlpid_NlpidSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Nlpid_NlpidSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Nlpid_NlpidSlice {
	t.Helper()
	c := &oc.CollectionE_Nlpid_NlpidSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Nlpid_NlpidSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Nlpid_NlpidSlice) bool) *oc.E_Nlpid_NlpidSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/nlpid/state/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath extracts the value of the leaf Nlpid from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Nlpid_NlpidSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid_NlpidPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) *oc.QualifiedE_Nlpid_NlpidSlice {
	t.Helper()
	qv := &oc.QualifiedE_Nlpid_NlpidSlice{
		Metadata: md,
	}
	val := parent.Nlpid
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOiPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/received-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath extracts the value of the leaf ReceivedSystemId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_ReceivedSystemIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ReceivedSystemId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/source-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath extracts the value of the leaf SourceSystemId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SourceSystemIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SourceSystemId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/purge-oi/state/system-id-count to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath extracts the value of the leaf SystemIdCount from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi_SystemIdCountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SystemIdCount
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_TLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_TLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_TLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_TLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_TLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_TLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_TLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_TLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) *oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_TLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath extracts the value of the leaf Length from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_LengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Length
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/undefined-tlvs/undefined-tlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetVersion2())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2PathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2PathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version2 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Version2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Version2Path extracts the value of the leaf Version2 from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Version2Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Version2
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetVersion())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/version to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_VersionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_VersionPath extracts the value of the leaf Version from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_VersionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Version
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_MetricStyle {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_MetricStylePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Get(t testing.TB) oc.E_IsisTypes_MetricStyle {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_MetricStyle {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_MetricStyle
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_MetricStylePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePathAny) Get(t testing.TB) []oc.E_IsisTypes_MetricStyle {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_MetricStyle
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_MetricStyle {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_MetricStyle{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_MetricStyle) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_MetricStylePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_MetricStyle) bool) *oc.E_IsisTypes_MetricStyleWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_MetricStyleWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_MetricStylePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_MetricStyle)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_MetricStyle) bool) *oc.E_IsisTypes_MetricStyleWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_MetricStylePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_MetricStyle) *oc.QualifiedE_IsisTypes_MetricStyle {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_MetricStyle) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_MetricStyle {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_MetricStyle{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_MetricStyle) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_MetricStyle) bool) *oc.E_IsisTypes_MetricStyleWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_MetricStylePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/metric-style to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_MetricStylePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_MetricStylePath extracts the value of the leaf MetricStyle from its parent oc.NetworkInstance_Protocol_Isis_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_MetricStyle.
func convertNetworkInstance_Protocol_Isis_Level_MetricStylePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level) *oc.QualifiedE_IsisTypes_MetricStyle {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_MetricStyle{
		Metadata: md,
	}
	val := parent.MetricStyle
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_RoutePreference
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_RoutePreference{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_RoutePreference)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_RoutePreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool) *oc.NetworkInstance_Protocol_Isis_Level_RoutePreferenceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreferenceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool) *oc.NetworkInstance_Protocol_Isis_Level_RoutePreferenceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_RoutePreference) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_RoutePreference {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_RoutePreference{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_RoutePreference) bool) *oc.NetworkInstance_Protocol_Isis_Level_RoutePreferenceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/external-route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath extracts the value of the leaf ExternalRoutePreference from its parent oc.NetworkInstance_Protocol_Isis_Level_RoutePreference
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_RoutePreference_ExternalRoutePreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_RoutePreference) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.ExternalRoutePreference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_RoutePreference", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/route-preference/state/internal-route-preference to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath extracts the value of the leaf InternalRoutePreference from its parent oc.NetworkInstance_Protocol_Isis_Level_RoutePreference
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_RoutePreference_InternalRoutePreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_RoutePreference) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.InternalRoutePreference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool) *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCountersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool) *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_SystemLevelCounters) bool) *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath extracts the value of the leaf AuthFails from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthFailsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AuthFails
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/auth-type-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath extracts the value of the leaf AuthTypeFails from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_AuthTypeFailsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AuthTypeFails
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/corrupted-lsps to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath extracts the value of the leaf CorruptedLsps from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_CorruptedLspsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.CorruptedLsps
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/database-overloads to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath extracts the value of the leaf DatabaseOverloads from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_DatabaseOverloadsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.DatabaseOverloads
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/exceed-max-seq-nums to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath extracts the value of the leaf ExceedMaxSeqNums from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ExceedMaxSeqNumsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ExceedMaxSeqNums
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/id-len-mismatch to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath extracts the value of the leaf IdLenMismatch from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_IdLenMismatchPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.IdLenMismatch
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/lsp-errors to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath extracts the value of the leaf LspErrors from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_LspErrorsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.LspErrors
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/manual-address-drop-from-areas to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath extracts the value of the leaf ManualAddressDropFromAreas from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_ManualAddressDropFromAreasPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ManualAddressDropFromAreas
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/max-area-address-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath extracts the value of the leaf MaxAreaAddressMismatches from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_MaxAreaAddressMismatchesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.MaxAreaAddressMismatches
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/own-lsp-purges to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath extracts the value of the leaf OwnLspPurges from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_OwnLspPurgesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.OwnLspPurges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/part-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath extracts the value of the leaf PartChanges from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_PartChangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.PartChanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/seq-num-skips to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath extracts the value of the leaf SeqNumSkips from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SeqNumSkipsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.SeqNumSkips
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_SystemLevelCounters", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/system-level-counters/state/spf-runs to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath extracts the value of the leaf SpfRuns from its parent oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_SystemLevelCounters_SpfRunsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.SpfRuns
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool) *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineeringWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineeringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool) *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineeringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_TrafficEngineering) bool) *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineeringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineeringPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv4-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath extracts the value of the leaf Ipv4RouterId from its parent oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv4RouterIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Ipv4RouterId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_TrafficEngineering", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/traffic-engineering/state/ipv6-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath extracts the value of the leaf Ipv6RouterId from its parent oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_TrafficEngineering_Ipv6RouterIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_TrafficEngineering) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Ipv6RouterId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a ONCE subscription.
func (n *NetworkInstance_Protocol_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_NamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name to the batch object.
func (n *NetworkInstance_Protocol_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_NamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/name to the batch object.
func (n *NetworkInstance_Protocol_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Protocol
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2Path) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2Path) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2PathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2PathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool) *oc.NetworkInstance_Protocol_Ospfv2Watcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool) *oc.NetworkInstance_Protocol_Ospfv2Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2Path) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2) *oc.QualifiedNetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2) bool) *oc.NetworkInstance_Protocol_Ospfv2Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2Path(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2 to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_AreaPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool) *oc.NetworkInstance_Protocol_Ospfv2_AreaWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_AreaWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool) *oc.NetworkInstance_Protocol_Ospfv2_AreaWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_AreaPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area) bool) *oc.NetworkInstance_Protocol_Ospfv2_AreaWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_AreaPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_AreaPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Identifier_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_IdentifierPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_IdentifierPath extracts the value of the leaf Identifier from its parent oc.NetworkInstance_Protocol_Ospfv2_Area
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union.
func convertNetworkInstance_Protocol_Ospfv2_Area_IdentifierPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Identifier_Union{
		Metadata: md,
	}
	val := parent.Identifier
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/authentication-type to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath extracts the value of the leaf AuthenticationType from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_AuthenticationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/enable-bfd/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_EnableBfd) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/hide-network to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath extracts the value of the leaf HideNetwork from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_HideNetworkPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HideNetwork
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/id to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_IdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath extracts the value of the leaf Id from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_IdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Id
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/lsa-filter/state/all to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath extracts the value of the leaf All from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter_AllPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.All
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MplsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSyncPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath extracts the value of the leaf PostSessionUpDelay from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.PostSessionUpDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/igp-ldp-sync/state/synchronized to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath extracts the value of the leaf Synchronized from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync_SynchronizedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Synchronized
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/mpls/state/traffic-engineering-metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath extracts the value of the leaf TrafficEngineeringMetric from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_TrafficEngineeringMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.TrafficEngineeringMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetMultiAreaAdjacencyPrimary())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/state/multi-area-adjacency-primary to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath extracts the value of the leaf MultiAreaAdjacencyPrimary from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_MultiAreaAdjacencyPrimaryPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MultiAreaAdjacencyPrimary
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) bool) *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Lookup(t testing.TB) *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Get(t testing.TB) oc.E_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePathAny) Lookup(t testing.TB) []*oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePathAny) Get(t testing.TB) []oc.E_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_OspfTypes_OSPF_NEIGHBOR_STATE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	c := &oc.CollectionE_OspfTypes_OSPF_NEIGHBOR_STATE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool) *oc.E_OspfTypes_OSPF_NEIGHBOR_STATEWatcher {
	t.Helper()
	w := &oc.E_OspfTypes_OSPF_NEIGHBOR_STATEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool) *oc.E_OspfTypes_OSPF_NEIGHBOR_STATEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Await(t testing.TB, timeout time.Duration, val oc.E_OspfTypes_OSPF_NEIGHBOR_STATE) *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	c := &oc.CollectionE_OspfTypes_OSPF_NEIGHBOR_STATE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE) bool) *oc.E_OspfTypes_OSPF_NEIGHBOR_STATEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/adjacency-state to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath extracts the value of the leaf AdjacencyState from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_AdjacencyStatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE {
	t.Helper()
	qv := &oc.QualifiedE_OspfTypes_OSPF_NEIGHBOR_STATE{
		Metadata: md,
	}
	val := parent.AdjacencyState
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/backup-designated-router to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath extracts the value of the leaf BackupDesignatedRouter from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_BackupDesignatedRouterPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.BackupDesignatedRouter
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/dead-time to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath extracts the value of the leaf DeadTime from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DeadTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.DeadTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated-router to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath extracts the value of the leaf DesignatedRouter from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_DesignatedRouterPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DesignatedRouter
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/last-established-time to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath extracts the value of the leaf LastEstablishedTime from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_LastEstablishedTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LastEstablishedTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a ONCE subscription.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor", gs, queryPath, true, false)
		return convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/optional-capabilities to the batch object.
func (n *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath extracts the value of the leaf OptionalCapabilities from its parent oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor_OptionalCapabilitiesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.OptionalCapabilities
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}
