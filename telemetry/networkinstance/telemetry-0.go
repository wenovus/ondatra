package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstancePath) Get(t testing.TB) *oc.NetworkInstance {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
func (n *NetworkInstancePathAny) Get(t testing.TB) []*oc.NetworkInstance {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance {
	t.Helper()
	c := &oc.CollectionNetworkInstance{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance)))
		return false
	})
	return c
}

func watch_NetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance) bool) *oc.NetworkInstanceWatcher {
	t.Helper()
	w := &oc.NetworkInstanceWatcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance) bool) *oc.NetworkInstanceWatcher {
	t.Helper()
	return watch_NetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstancePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance) *oc.QualifiedNetworkInstance {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance to the batch object.
func (n *NetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance {
	t.Helper()
	c := &oc.CollectionNetworkInstance{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance) bool) *oc.NetworkInstanceWatcher {
	t.Helper()
	return watch_NetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance to the batch object.
func (n *NetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_AftsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_AftsPath) Get(t testing.TB) *oc.NetworkInstance_Afts {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_AftsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts with a ONCE subscription.
func (n *NetworkInstance_AftsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_AftsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts)))
		return false
	})
	return c
}

func watch_NetworkInstance_AftsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts) bool) *oc.NetworkInstance_AftsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_AftsWatcher{}
	gs := &oc.NetworkInstance_Afts{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_AftsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts) bool) *oc.NetworkInstance_AftsWatcher {
	t.Helper()
	return watch_NetworkInstance_AftsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_AftsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts) *oc.QualifiedNetworkInstance_Afts {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts to the batch object.
func (n *NetworkInstance_AftsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_AftsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_AftsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts) bool) *oc.NetworkInstance_AftsWatcher {
	t.Helper()
	return watch_NetworkInstance_AftsPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts to the batch object.
func (n *NetworkInstance_AftsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_Ipv4Entry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Get(t testing.TB) *oc.NetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4EntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_Ipv4Entry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_Ipv4Entry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4EntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_Ipv4Entry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_Ipv4Entry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_Ipv4Entry{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_Ipv4Entry)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4EntryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool) *oc.NetworkInstance_Afts_Ipv4EntryWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_Ipv4EntryWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_Ipv4Entry{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_Ipv4Entry)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool) *oc.NetworkInstance_Afts_Ipv4EntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4EntryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedNetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry to the batch object.
func (n *NetworkInstance_Afts_Ipv4EntryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4EntryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_Ipv4Entry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_Ipv4Entry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4EntryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv4Entry) bool) *oc.NetworkInstance_Afts_Ipv4EntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4EntryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry to the batch object.
func (n *NetworkInstance_Afts_Ipv4EntryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Lookup(t testing.TB) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Get(t testing.TB) oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPathAny) Lookup(t testing.TB) []*oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_AftTypes_EncapsulationHeaderType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPathAny) Get(t testing.TB) []oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_AftTypes_EncapsulationHeaderType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	w := &oc.E_AftTypes_EncapsulationHeaderTypeWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_AftTypes_EncapsulationHeaderType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Await(t testing.TB, timeout time.Duration, val oc.E_AftTypes_EncapsulationHeaderType) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/decapsulate-header to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath extracts the value of the leaf DecapsulateHeader from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedE_AftTypes_EncapsulationHeaderType.
func convertNetworkInstance_Afts_Ipv4Entry_DecapsulateHeaderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	qv := &oc.QualifiedE_AftTypes_EncapsulationHeaderType{
		Metadata: md,
	}
	val := parent.DecapsulateHeader
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_EntryMetadataPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_EntryMetadataPath extracts the value of the leaf EntryMetadata from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Afts_Ipv4Entry_EntryMetadataPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.EntryMetadata
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath extracts the value of the leaf NextHopGroupNetworkInstance from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHopGroupNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv4Entry_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_OctetsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath extracts the value of the leaf OctetsForwarded from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv4Entry_OctetsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OctetsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Get(t testing.TB) oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPathAny) Get(t testing.TB) []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	w := &oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_OriginProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_OriginProtocolPath extracts the value of the leaf OriginProtocol from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE.
func convertNetworkInstance_Afts_Ipv4Entry_OriginProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE{
		Metadata: md,
	}
	val := parent.OriginProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_PacketsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath extracts the value of the leaf PacketsForwarded from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv4Entry_PacketsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PacketsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv4Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv4Entry_PrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv4Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv4Entry_PrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv4Entry_PrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv4Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv4Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv4Entry_PrefixPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_PrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv4Entry_PrefixPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/prefix to the batch object.
func (n *NetworkInstance_Afts_Ipv4Entry_PrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv4Entry_PrefixPath extracts the value of the leaf Prefix from its parent oc.NetworkInstance_Afts_Ipv4Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_Ipv4Entry_PrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv4Entry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Prefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_Ipv6Entry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Get(t testing.TB) *oc.NetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6EntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_Ipv6Entry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_Ipv6Entry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6EntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_Ipv6Entry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_Ipv6Entry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_Ipv6Entry{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_Ipv6Entry)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6EntryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool) *oc.NetworkInstance_Afts_Ipv6EntryWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_Ipv6EntryWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_Ipv6Entry{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_Ipv6Entry)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool) *oc.NetworkInstance_Afts_Ipv6EntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6EntryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedNetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry to the batch object.
func (n *NetworkInstance_Afts_Ipv6EntryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6EntryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_Ipv6Entry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_Ipv6Entry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6EntryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_Ipv6Entry) bool) *oc.NetworkInstance_Afts_Ipv6EntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6EntryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry to the batch object.
func (n *NetworkInstance_Afts_Ipv6EntryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Lookup(t testing.TB) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Get(t testing.TB) oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPathAny) Lookup(t testing.TB) []*oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_AftTypes_EncapsulationHeaderType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPathAny) Get(t testing.TB) []oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_AftTypes_EncapsulationHeaderType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	w := &oc.E_AftTypes_EncapsulationHeaderTypeWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_AftTypes_EncapsulationHeaderType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Await(t testing.TB, timeout time.Duration, val oc.E_AftTypes_EncapsulationHeaderType) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/decapsulate-header to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath extracts the value of the leaf DecapsulateHeader from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedE_AftTypes_EncapsulationHeaderType.
func convertNetworkInstance_Afts_Ipv6Entry_DecapsulateHeaderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	qv := &oc.QualifiedE_AftTypes_EncapsulationHeaderType{
		Metadata: md,
	}
	val := parent.DecapsulateHeader
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_EntryMetadataPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_EntryMetadataPath extracts the value of the leaf EntryMetadata from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Afts_Ipv6Entry_EntryMetadataPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.EntryMetadata
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath extracts the value of the leaf NextHopGroupNetworkInstance from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHopGroupNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv6Entry_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_OctetsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath extracts the value of the leaf OctetsForwarded from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv6Entry_OctetsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OctetsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Get(t testing.TB) oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPathAny) Get(t testing.TB) []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	w := &oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_OriginProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_OriginProtocolPath extracts the value of the leaf OriginProtocol from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE.
func convertNetworkInstance_Afts_Ipv6Entry_OriginProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE{
		Metadata: md,
	}
	val := parent.OriginProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_PacketsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath extracts the value of the leaf PacketsForwarded from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_Ipv6Entry_PacketsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PacketsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_Ipv6Entry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_Ipv6Entry_PrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_Ipv6Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_Ipv6Entry_PrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a ONCE subscription.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_Ipv6Entry_PrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_Ipv6Entry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_Ipv6Entry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_Ipv6Entry_PrefixPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_PrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_Ipv6Entry_PrefixPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/prefix to the batch object.
func (n *NetworkInstance_Afts_Ipv6Entry_PrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_Ipv6Entry_PrefixPath extracts the value of the leaf Prefix from its parent oc.NetworkInstance_Afts_Ipv6Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_Ipv6Entry_PrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_Ipv6Entry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Prefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_LabelEntry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_LabelEntry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntryPath) Get(t testing.TB) *oc.NetworkInstance_Afts_LabelEntry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_LabelEntry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_LabelEntry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_LabelEntry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_LabelEntry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_LabelEntry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_LabelEntry{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_LabelEntry)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool) *oc.NetworkInstance_Afts_LabelEntryWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_LabelEntryWatcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_LabelEntry{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_LabelEntry)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool) *oc.NetworkInstance_Afts_LabelEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntryPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedNetworkInstance_Afts_LabelEntry {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry to the batch object.
func (n *NetworkInstance_Afts_LabelEntryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry) bool) *oc.NetworkInstance_Afts_LabelEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry to the batch object.
func (n *NetworkInstance_Afts_LabelEntryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_EntryMetadataPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_EntryMetadataPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_EntryMetadataPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_EntryMetadataPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_EntryMetadataPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_EntryMetadataPath extracts the value of the leaf EntryMetadata from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Afts_LabelEntry_EntryMetadataPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.EntryMetadata
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_LabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Get(t testing.TB) oc.NetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_LabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_LabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_LabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Afts_LabelEntry_Label_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_LabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool) *oc.NetworkInstance_Afts_LabelEntry_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_LabelEntry_Label_UnionWatcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_LabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool) *oc.NetworkInstance_Afts_LabelEntry_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_LabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Afts_LabelEntry_Label_Union) *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_LabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_LabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_LabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union) bool) *oc.NetworkInstance_Afts_LabelEntry_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_LabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_LabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_LabelPath extracts the value of the leaf Label from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union.
func convertNetworkInstance_Afts_LabelEntry_LabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Afts_LabelEntry_Label_Union{
		Metadata: md,
	}
	val := parent.Label
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath extracts the value of the leaf NextHopGroupNetworkInstance from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_LabelEntry_NextHopGroupNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHopGroupNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_LabelEntry_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_OctetsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_OctetsForwardedPath extracts the value of the leaf OctetsForwarded from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_LabelEntry_OctetsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OctetsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_PacketsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_PacketsForwardedPath extracts the value of the leaf PacketsForwarded from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_LabelEntry_PacketsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PacketsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_LabelEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Get(t testing.TB) []oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_LabelEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a ONCE subscription.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Afts_LabelEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_LabelEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union) *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack to the batch object.
func (n *NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath extracts the value of the leaf PoppedMplsLabelStack from its parent oc.NetworkInstance_Afts_LabelEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice.
func convertNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_LabelEntry) *oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_UnionSlice{
		Metadata: md,
	}
	val := parent.PoppedMplsLabelStack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_MacEntry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_MacEntry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntryPath) Get(t testing.TB) *oc.NetworkInstance_Afts_MacEntry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_MacEntry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_MacEntry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_MacEntry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_MacEntry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_MacEntry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_MacEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_MacEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_MacEntry) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_MacEntry{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_MacEntry)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_MacEntry) bool) *oc.NetworkInstance_Afts_MacEntryWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_MacEntryWatcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_MacEntry{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_MacEntry)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_MacEntry) bool) *oc.NetworkInstance_Afts_MacEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntryPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedNetworkInstance_Afts_MacEntry {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_MacEntry) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry to the batch object.
func (n *NetworkInstance_Afts_MacEntryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_MacEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_MacEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_MacEntry) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_MacEntry) bool) *oc.NetworkInstance_Afts_MacEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry to the batch object.
func (n *NetworkInstance_Afts_MacEntryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_EntryMetadataPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_EntryMetadataPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_EntryMetadataPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_EntryMetadataPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_MacEntry_EntryMetadataPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_EntryMetadataPath extracts the value of the leaf EntryMetadata from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Afts_MacEntry_EntryMetadataPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.EntryMetadata
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_MacAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_MacAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_MacAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_MacAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_MacAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_MacAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_MacEntry_MacAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_MacAddressPath extracts the value of the leaf MacAddress from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_MacEntry_MacAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MacAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath extracts the value of the leaf NextHopGroupNetworkInstance from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_MacEntry_NextHopGroupNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHopGroupNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_MacEntry_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_MacEntry_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_OctetsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_OctetsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_OctetsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_OctetsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_MacEntry_OctetsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_OctetsForwardedPath extracts the value of the leaf OctetsForwarded from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_MacEntry_OctetsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OctetsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_MacEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_MacEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_MacEntry_PacketsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_MacEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_MacEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_MacEntry_PacketsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_MacEntry_PacketsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_MacEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_MacEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_MacEntry_PacketsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_MacEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_MacEntry_PacketsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_MacEntry_PacketsForwardedPath extracts the value of the leaf PacketsForwarded from its parent oc.NetworkInstance_Afts_MacEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_MacEntry_PacketsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_MacEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PacketsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHopGroup {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroupPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHopGroup {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHopGroup {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHopGroup
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHopGroup{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroupPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHopGroup {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHopGroup
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHopGroup{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHopGroup)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool) *oc.NetworkInstance_Afts_NextHopGroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHopGroupWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHopGroup)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool) *oc.NetworkInstance_Afts_NextHopGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHopGroup) *oc.QualifiedNetworkInstance_Afts_NextHopGroup {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup) bool) *oc.NetworkInstance_Afts_NextHopGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/backup-next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath extracts the value of the leaf BackupNextHopGroup from its parent oc.NetworkInstance_Afts_NextHopGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_BackupNextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BackupNextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_ColorPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_ColorPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_ColorPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_ColorPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ColorPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ColorPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/color to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ColorPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_ColorPath extracts the value of the leaf Color from its parent oc.NetworkInstance_Afts_NextHopGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_ColorPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Color
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHopGroup_Condition
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHopGroup_Condition)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_ConditionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool) *oc.NetworkInstance_Afts_NextHopGroup_ConditionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHopGroup_ConditionWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool) *oc.NetworkInstance_Afts_NextHopGroup_ConditionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ConditionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHopGroup_Condition) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition) bool) *oc.NetworkInstance_Afts_NextHopGroup_ConditionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ConditionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ConditionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Lookup(t testing.TB) *oc.QualifiedUint8Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Get(t testing.TB) []uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPathAny) Get(t testing.TB) [][]uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8Slice {
	t.Helper()
	c := &oc.CollectionUint8Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8Slice) bool) *oc.Uint8SliceWatcher {
	t.Helper()
	w := &oc.Uint8SliceWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8Slice) bool) *oc.Uint8SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Await(t testing.TB, timeout time.Duration, val []uint8) *oc.QualifiedUint8Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8Slice {
	t.Helper()
	c := &oc.CollectionUint8Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8Slice) bool) *oc.Uint8SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/dscp to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_DscpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_DscpPath extracts the value of the leaf Dscp from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8Slice.
func convertNetworkInstance_Afts_NextHopGroup_Condition_DscpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition) *oc.QualifiedUint8Slice {
	t.Helper()
	qv := &oc.QualifiedUint8Slice{
		Metadata: md,
	}
	val := parent.Dscp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_IdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_IdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_IdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_IdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_IdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_IdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_IdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_IdPath extracts the value of the leaf Id from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_Condition_IdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Id
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool) *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterfaceWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool) *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_Condition_InputInterface) bool) *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath extracts the value of the leaf Id from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_IdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Id
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/interface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition_InputInterface", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface/state/subinterface to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Afts_NextHopGroup_Condition_InputInterface_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_Condition{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_Condition", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_NextHopGroup_Condition
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_Condition_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_Condition) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_IdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_IdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_IdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_IdPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_IdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_IdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_IdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_IdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_IdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_IdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_IdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_IdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_IdPath extracts the value of the leaf Id from its parent oc.NetworkInstance_Afts_NextHopGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_IdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Id
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHopGroup_NextHop
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_NextHop{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHopGroup_NextHop)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool) *oc.NetworkInstance_Afts_NextHopGroup_NextHopWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHopGroup_NextHopWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool) *oc.NetworkInstance_Afts_NextHopGroup_NextHopWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHopGroup_NextHop) *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHopGroup_NextHop {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHopGroup_NextHop{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHopGroup_NextHop) bool) *oc.NetworkInstance_Afts_NextHopGroup_NextHopWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHopPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/index to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_NextHop_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Afts_NextHopGroup_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_NextHop_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_NextHop) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop/state/weight to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_NextHop_WeightPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_NextHop_WeightPath extracts the value of the leaf Weight from its parent oc.NetworkInstance_Afts_NextHopGroup_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_NextHop_WeightPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup_NextHop) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Weight
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHopGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHopGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHopGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHopGroup", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/state/programmed-id to the batch object.
func (n *NetworkInstance_Afts_NextHopGroup_ProgrammedIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHopGroup_ProgrammedIdPath extracts the value of the leaf ProgrammedId from its parent oc.NetworkInstance_Afts_NextHopGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHopGroup_ProgrammedIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHopGroup) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ProgrammedId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHopPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHop {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHop{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHopPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHop {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHop {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHop
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHop{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHopPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHop {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHop
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHop{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHop)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop) bool) *oc.NetworkInstance_Afts_NextHopWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHopWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHop{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHop)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop) bool) *oc.NetworkInstance_Afts_NextHopWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHopPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedNetworkInstance_Afts_NextHop {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHop) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop to the batch object.
func (n *NetworkInstance_Afts_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop) bool) *oc.NetworkInstance_Afts_NextHopWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHopPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop to the batch object.
func (n *NetworkInstance_Afts_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Lookup(t testing.TB) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Get(t testing.TB) oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPathAny) Lookup(t testing.TB) []*oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_AftTypes_EncapsulationHeaderType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPathAny) Get(t testing.TB) []oc.E_AftTypes_EncapsulationHeaderType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_AftTypes_EncapsulationHeaderType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	w := &oc.E_AftTypes_EncapsulationHeaderTypeWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_AftTypes_EncapsulationHeaderType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Await(t testing.TB, timeout time.Duration, val oc.E_AftTypes_EncapsulationHeaderType) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header to the batch object.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	c := &oc.CollectionE_AftTypes_EncapsulationHeaderType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_AftTypes_EncapsulationHeaderType) bool) *oc.E_AftTypes_EncapsulationHeaderTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/encapsulate-header to the batch object.
func (n *NetworkInstance_Afts_NextHop_EncapsulateHeaderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_EncapsulateHeaderPath extracts the value of the leaf EncapsulateHeader from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedE_AftTypes_EncapsulationHeaderType.
func convertNetworkInstance_Afts_NextHop_EncapsulateHeaderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedE_AftTypes_EncapsulationHeaderType {
	t.Helper()
	qv := &oc.QualifiedE_AftTypes_EncapsulationHeaderType{
		Metadata: md,
	}
	val := parent.EncapsulateHeader
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_IndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index to the batch object.
func (n *NetworkInstance_Afts_NextHop_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/index to the batch object.
func (n *NetworkInstance_Afts_NextHop_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHop_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHop_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHop_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool) *oc.NetworkInstance_Afts_NextHop_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHop_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool) *oc.NetworkInstance_Afts_NextHop_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHop_InterfaceRef) *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_InterfaceRef) bool) *oc.NetworkInstance_Afts_NextHop_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRefPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Afts_NextHop_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_InterfaceRef", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Afts_NextHop_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Afts_NextHop_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_IpAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_IpAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_IpAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_IpAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_IpAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_IpAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/ip-address to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_IpAddressPath extracts the value of the leaf IpAddress from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_IpAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.IpAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_IpInIp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Get(t testing.TB) *oc.NetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_IpInIpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_NextHop_IpInIp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_IpInIp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_NextHop_IpInIp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_IpInIpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool) *oc.NetworkInstance_Afts_NextHop_IpInIpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHop_IpInIpWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool) *oc.NetworkInstance_Afts_NextHop_IpInIpWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_NextHop_IpInIp) *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_IpInIp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_IpInIp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_IpInIp) bool) *oc.NetworkInstance_Afts_NextHop_IpInIpWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_IpInIp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/dst-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIp_DstIpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_IpInIp_DstIpPath extracts the value of the leaf DstIp from its parent oc.NetworkInstance_Afts_NextHop_IpInIp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_IpInIp_DstIpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop_IpInIp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DstIp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop_IpInIp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop_IpInIp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop_IpInIp", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip/state/src-ip to the batch object.
func (n *NetworkInstance_Afts_NextHop_IpInIp_SrcIpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_IpInIp_SrcIpPath extracts the value of the leaf SrcIp from its parent oc.NetworkInstance_Afts_NextHop_IpInIp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_IpInIp_SrcIpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop_IpInIp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SrcIp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_LspNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_LspNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_LspNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_LspNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_LspNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_LspNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_LspNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name to the batch object.
func (n *NetworkInstance_Afts_NextHop_LspNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_LspNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_LspNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_LspNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/lsp-name to the batch object.
func (n *NetworkInstance_Afts_NextHop_LspNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_LspNamePath extracts the value of the leaf LspName from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_LspNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LspName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_MacAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_MacAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_MacAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_MacAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_MacAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_MacAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_MacAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_NextHop_MacAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_MacAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_MacAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_MacAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_NextHop_MacAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_MacAddressPath extracts the value of the leaf MacAddress from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_NextHop_MacAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MacAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_OriginProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Get(t testing.TB) oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_OriginProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPathAny) Get(t testing.TB) []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_OriginProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	w := &oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_OriginProtocolPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_OriginProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_OriginProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/origin-protocol to the batch object.
func (n *NetworkInstance_Afts_NextHop_OriginProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_OriginProtocolPath extracts the value of the leaf OriginProtocol from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE.
func convertNetworkInstance_Afts_NextHop_OriginProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE{
		Metadata: md,
	}
	val := parent.OriginProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_ProgrammedIndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_ProgrammedIndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_ProgrammedIndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_ProgrammedIndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_ProgrammedIndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index to the batch object.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_ProgrammedIndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/programmed-index to the batch object.
func (n *NetworkInstance_Afts_NextHop_ProgrammedIndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_ProgrammedIndexPath extracts the value of the leaf ProgrammedIndex from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_NextHop_ProgrammedIndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ProgrammedIndex
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_NextHop{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_NextHop", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Get(t testing.TB) []oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_NextHop{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_NextHop", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a ONCE subscription.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Afts_NextHop{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_NextHop", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union) *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack to the batch object.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice) bool) *oc.NetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack to the batch object.
func (n *NetworkInstance_Afts_NextHop_PushedMplsLabelStackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_NextHop_PushedMplsLabelStackPath extracts the value of the leaf PushedMplsLabelStack from its parent oc.NetworkInstance_Afts_NextHop
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice.
func convertNetworkInstance_Afts_NextHop_PushedMplsLabelStackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_NextHop) *oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Afts_NextHop_PushedMplsLabelStack_UnionSlice{
		Metadata: md,
	}
	val := parent.PushedMplsLabelStack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Get(t testing.TB) *oc.NetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Afts_PolicyForwardingEntry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Afts_PolicyForwardingEntry)))
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntryPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntryWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_PolicyForwardingEntryWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntryPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntryPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntryPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/entry-metadata to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath extracts the value of the leaf EntryMetadata from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Afts_PolicyForwardingEntry_EntryMetadataPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.EntryMetadata
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/index to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_PolicyForwardingEntry_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-dscp to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpDscpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath extracts the value of the leaf IpDscp from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Afts_PolicyForwardingEntry_IpDscpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.IpDscp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-prefix to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath extracts the value of the leaf IpPrefix from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_PolicyForwardingEntry_IpPrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.IpPrefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Get(t testing.TB) oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPathAny) Get(t testing.TB) []oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_UnionWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath extracts the value of the leaf IpProtocol from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union.
func convertNetworkInstance_Afts_PolicyForwardingEntry_IpProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union{
		Metadata: md,
	}
	val := parent.IpProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-dst-port to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath extracts the value of the leaf L4DstPort from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Afts_PolicyForwardingEntry_L4DstPortPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.L4DstPort
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/l4-src-port to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath extracts the value of the leaf L4SrcPort from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Afts_PolicyForwardingEntry_L4SrcPortPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.L4SrcPort
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mac-address to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MacAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath extracts the value of the leaf MacAddress from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_PolicyForwardingEntry_MacAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MacAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Get(t testing.TB) oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) bool) *oc.NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath extracts the value of the leaf MplsLabel from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union.
func convertNetworkInstance_Afts_PolicyForwardingEntry_MplsLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union{
		Metadata: md,
	}
	val := parent.MplsLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-tc to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_MplsTcPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath extracts the value of the leaf MplsTc from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Afts_PolicyForwardingEntry_MplsTcPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MplsTc
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group-network-instance to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath extracts the value of the leaf NextHopGroupNetworkInstance from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHopGroupNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/next-hop-group to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath extracts the value of the leaf NextHopGroup from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_PolicyForwardingEntry_NextHopGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHopGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/octets-forwarded to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath extracts the value of the leaf OctetsForwarded from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_PolicyForwardingEntry_OctetsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OctetsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a ONCE subscription.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Afts_PolicyForwardingEntry{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Afts_PolicyForwardingEntry", gs, queryPath, true, false)
		return convertNetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/packets-forwarded to the batch object.
func (n *NetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath extracts the value of the leaf PacketsForwarded from its parent oc.NetworkInstance_Afts_PolicyForwardingEntry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Afts_PolicyForwardingEntry_PacketsForwardedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Afts_PolicyForwardingEntry) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PacketsForwarded
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPointPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPointPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPointPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
func (n *NetworkInstance_ConnectionPointPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPointPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_ConnectionPoint)))
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPointPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint) bool) *oc.NetworkInstance_ConnectionPointWatcher {
	t.Helper()
	w := &oc.NetworkInstance_ConnectionPointWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_ConnectionPoint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPointPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint) bool) *oc.NetworkInstance_ConnectionPointWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPointPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPointPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_ConnectionPoint) *oc.QualifiedNetworkInstance_ConnectionPoint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_ConnectionPoint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point to the batch object.
func (n *NetworkInstance_ConnectionPointPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPointPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPointPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint) bool) *oc.NetworkInstance_ConnectionPointWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPointPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point to the batch object.
func (n *NetworkInstance_ConnectionPointPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_ConnectionPointIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/state/connection-point-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath extracts the value of the leaf ConnectionPointId from its parent oc.NetworkInstance_ConnectionPoint
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ConnectionPointId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_ConnectionPoint_Endpoint)))
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_EndpointPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool) *oc.NetworkInstance_ConnectionPoint_EndpointWatcher {
	t.Helper()
	w := &oc.NetworkInstance_ConnectionPoint_EndpointWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool) *oc.NetworkInstance_ConnectionPoint_EndpointWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_EndpointPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint to the batch object.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint) bool) *oc.NetworkInstance_ConnectionPoint_EndpointWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_EndpointPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint to the batch object.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_ActivePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_ActivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_ActivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_ActivePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_ActivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_ActivePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/active to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_ActivePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_ActivePath extracts the value of the leaf Active from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_ConnectionPoint_Endpoint_ActivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Active
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/endpoint-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath extracts the value of the leaf EndpointId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.EndpointId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Local
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Local{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_ConnectionPoint_Endpoint_Local)))
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_LocalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_LocalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_ConnectionPoint_Endpoint_LocalWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_LocalWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_LocalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Local{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_LocalWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_LocalPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/interface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath extracts the value of the leaf SiteId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-offset to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath extracts the value of the leaf SiteLabelBlockOffset from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteLabelBlockOffset
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/site-label-block-size to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath extracts the value of the leaf SiteLabelBlockSize from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteLabelBlockSize
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/state/subinterface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/precedence to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath extracts the value of the leaf Precedence from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Precedence
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Remote{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_ConnectionPoint_Endpoint_Remote)))
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_RemotePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_RemoteWatcher {
	t.Helper()
	w := &oc.NetworkInstance_ConnectionPoint_Endpoint_RemoteWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_RemoteWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_RemotePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Remote{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_RemoteWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_RemotePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/remote-system to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath extracts the value of the leaf RemoteSystem from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteSystem
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/site-id to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath extracts the value of the leaf SiteId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/state/virtual-circuit-identifier to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath extracts the value of the leaf VirtualCircuitIdentifier from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.VirtualCircuitIdentifier
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENDPOINT_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENDPOINT_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool) *oc.E_NetworkInstanceTypes_ENDPOINT_TYPEWatcher {
	t.Helper()
	w := &oc.E_NetworkInstanceTypes_ENDPOINT_TYPEWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool) *oc.E_NetworkInstanceTypes_ENDPOINT_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_NetworkInstanceTypes_ENDPOINT_TYPE) *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENDPOINT_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE) bool) *oc.E_NetworkInstanceTypes_ENDPOINT_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_TypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/state/type to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE.
func convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan)))
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_VxlanPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_VxlanWatcher {
	t.Helper()
	w := &oc.NetworkInstance_ConnectionPoint_Endpoint_VxlanWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_VxlanWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_VxlanPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	c := &oc.CollectionNetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan) bool) *oc.NetworkInstance_ConnectionPoint_Endpoint_VxlanWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_VxlanPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/description to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/enabled to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, false)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", gs, queryPath, true, false)
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/state/source-interface to the batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath extracts the value of the leaf SourceInterface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SourceInterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/state/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/state/description with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/state/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/state/description with a ONCE subscription.
func (n *NetworkInstance_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_DescriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_DescriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, true, false)
		return convertNetworkInstance_DescriptionPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_DescriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_DescriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/state/description with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_DescriptionPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/state/description failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/description to the batch object.
func (n *NetworkInstance_DescriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_DescriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_DescriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_DescriptionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/description to the batch object.
func (n *NetworkInstance_DescriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Lookup(t testing.TB) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_EnabledAddressFamiliesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Get(t testing.TB) []oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_EnabledAddressFamiliesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a ONCE subscription.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Get(t testing.TB) [][]oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Types_ADDRESS_FAMILY
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	c := &oc.CollectionE_Types_ADDRESS_FAMILYSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_EnabledAddressFamiliesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool) *oc.E_Types_ADDRESS_FAMILYSliceWatcher {
	t.Helper()
	w := &oc.E_Types_ADDRESS_FAMILYSliceWatcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, true, false)
		return convertNetworkInstance_EnabledAddressFamiliesPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Types_ADDRESS_FAMILYSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool) *oc.E_Types_ADDRESS_FAMILYSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_EnabledAddressFamiliesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Types_ADDRESS_FAMILY) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families to the batch object.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	c := &oc.CollectionE_Types_ADDRESS_FAMILYSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Types_ADDRESS_FAMILYSlice) bool) *oc.E_Types_ADDRESS_FAMILYSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_EnabledAddressFamiliesPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/enabled-address-families to the batch object.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_EnabledAddressFamiliesPath extracts the value of the leaf EnabledAddressFamilies from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Types_ADDRESS_FAMILYSlice.
func convertNetworkInstance_EnabledAddressFamiliesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	qv := &oc.QualifiedE_Types_ADDRESS_FAMILYSlice{
		Metadata: md,
	}
	val := parent.EnabledAddressFamilies
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/state/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a ONCE subscription.
func (n *NetworkInstance_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, true, false)
		return convertNetworkInstance_EnabledPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/enabled to the batch object.
func (n *NetworkInstance_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_EnabledPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/enabled to the batch object.
func (n *NetworkInstance_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EncapsulationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Encapsulation {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EncapsulationPath) Get(t testing.TB) *oc.NetworkInstance_Encapsulation {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EncapsulationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Encapsulation {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Encapsulation
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
func (n *NetworkInstance_EncapsulationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Encapsulation {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Encapsulation
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EncapsulationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Encapsulation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Encapsulation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Encapsulation) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Encapsulation)))
		return false
	})
	return c
}

func watch_NetworkInstance_EncapsulationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Encapsulation) bool) *oc.NetworkInstance_EncapsulationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_EncapsulationWatcher{}
	gs := &oc.NetworkInstance_Encapsulation{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Encapsulation", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Encapsulation)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EncapsulationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Encapsulation) bool) *oc.NetworkInstance_EncapsulationWatcher {
	t.Helper()
	return watch_NetworkInstance_EncapsulationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_EncapsulationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Encapsulation) *oc.QualifiedNetworkInstance_Encapsulation {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Encapsulation) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/encapsulation failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation to the batch object.
func (n *NetworkInstance_EncapsulationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EncapsulationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Encapsulation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Encapsulation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Encapsulation) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EncapsulationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Encapsulation) bool) *oc.NetworkInstance_EncapsulationWatcher {
	t.Helper()
	return watch_NetworkInstance_EncapsulationPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation to the batch object.
func (n *NetworkInstance_EncapsulationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Encapsulation_ControlWordPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_ControlWordPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Encapsulation_ControlWordPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Encapsulation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Encapsulation", gs, queryPath, true, false)
		return convertNetworkInstance_Encapsulation_ControlWordPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_ControlWordPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word to the batch object.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_ControlWordPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/control-word to the batch object.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Encapsulation_ControlWordPath extracts the value of the leaf ControlWord from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Encapsulation_ControlWordPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ControlWord
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Encapsulation_EncapsulationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_EncapsulationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENCAPSULATION
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Encapsulation_EncapsulationTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	w := &oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher{}
	gs := &oc.NetworkInstance_Encapsulation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Encapsulation", gs, queryPath, true, false)
		return convertNetworkInstance_Encapsulation_EncapsulationTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_EncapsulationTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type to the batch object.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_EncapsulationTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/encapsulation-type to the batch object.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Encapsulation_EncapsulationTypePath extracts the value of the leaf EncapsulationType from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION.
func convertNetworkInstance_Encapsulation_EncapsulationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION{
		Metadata: md,
	}
	val := parent.EncapsulationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Encapsulation_LabelAllocationModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_LabelAllocationModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Encapsulation_LabelAllocationModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool) *oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODEWatcher {
	t.Helper()
	w := &oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODEWatcher{}
	gs := &oc.NetworkInstance_Encapsulation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Encapsulation", gs, queryPath, true, false)
		return convertNetworkInstance_Encapsulation_LabelAllocationModePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool) *oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_LabelAllocationModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Await(t testing.TB, timeout time.Duration, val oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode to the batch object.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) bool) *oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Encapsulation_LabelAllocationModePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/encapsulation/state/label-allocation-mode to the batch object.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Encapsulation_LabelAllocationModePath extracts the value of the leaf LabelAllocationMode from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE.
func convertNetworkInstance_Encapsulation_LabelAllocationModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE{
		Metadata: md,
	}
	val := parent.LabelAllocationMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EvpnPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EvpnPath) Get(t testing.TB) *oc.NetworkInstance_Evpn {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EvpnPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
func (n *NetworkInstance_EvpnPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EvpnPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn)))
		return false
	})
	return c
}

func watch_NetworkInstance_EvpnPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn) bool) *oc.NetworkInstance_EvpnWatcher {
	t.Helper()
	w := &oc.NetworkInstance_EvpnWatcher{}
	gs := &oc.NetworkInstance_Evpn{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EvpnPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn) bool) *oc.NetworkInstance_EvpnWatcher {
	t.Helper()
	return watch_NetworkInstance_EvpnPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_EvpnPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn) *oc.QualifiedNetworkInstance_Evpn {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn to the batch object.
func (n *NetworkInstance_EvpnPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_EvpnPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_EvpnPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn) bool) *oc.NetworkInstance_EvpnWatcher {
	t.Helper()
	return watch_NetworkInstance_EvpnPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn to the batch object.
func (n *NetworkInstance_EvpnPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EthernetSegment
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EthernetSegment)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegmentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool) *oc.NetworkInstance_Evpn_EthernetSegmentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EthernetSegmentWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EthernetSegment)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool) *oc.NetworkInstance_Evpn_EthernetSegmentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegmentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment) bool) *oc.NetworkInstance_Evpn_EthernetSegmentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegmentPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EthernetSegment_DfElection
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment_DfElection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EthernetSegment_DfElection)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_DfElectionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool) *oc.NetworkInstance_Evpn_EthernetSegment_DfElectionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EthernetSegment_DfElectionWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool) *oc.NetworkInstance_Evpn_EthernetSegment_DfElectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElectionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment_DfElection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection) bool) *oc.NetworkInstance_Evpn_EthernetSegment_DfElectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElectionPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Lookup(t testing.TB) *oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Get(t testing.TB) oc.E_DfElection_DfElectionMethod {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_DfElection_DfElectionMethod
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Get(t testing.TB) []oc.E_DfElection_DfElectionMethod {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_DfElection_DfElectionMethod
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_DfElection_DfElectionMethod {
	t.Helper()
	c := &oc.CollectionE_DfElection_DfElectionMethod{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_DfElection_DfElectionMethod) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_DfElection_DfElectionMethod) bool) *oc.E_DfElection_DfElectionMethodWatcher {
	t.Helper()
	w := &oc.E_DfElection_DfElectionMethodWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_DfElection_DfElectionMethod)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_DfElection_DfElectionMethod) bool) *oc.E_DfElection_DfElectionMethodWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Await(t testing.TB, timeout time.Duration, val oc.E_DfElection_DfElectionMethod) *oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_DfElection_DfElectionMethod) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_DfElection_DfElectionMethod {
	t.Helper()
	c := &oc.CollectionE_DfElection_DfElectionMethod{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_DfElection_DfElectionMethod) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_DfElection_DfElectionMethod) bool) *oc.E_DfElection_DfElectionMethodWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/df-election-method to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath extracts the value of the leaf DfElectionMethod from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedE_DfElection_DfElectionMethod.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	qv := &oc.QualifiedE_DfElection_DfElectionMethod{
		Metadata: md,
	}
	val := parent.DfElectionMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/election-wait-time to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath extracts the value of the leaf ElectionWaitTime from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ElectionWaitTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/preference to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRevertive())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/state/revertive to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath extracts the value of the leaf Revertive from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Revertive
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Get(t testing.TB) oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Get(t testing.TB) []oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment_Esi_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_EsiPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool) *oc.NetworkInstance_Evpn_EthernetSegment_Esi_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EthernetSegment_Esi_UnionWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool) *oc.NetworkInstance_Evpn_EthernetSegment_Esi_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_EsiPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EthernetSegment_Esi_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union) bool) *oc.NetworkInstance_Evpn_EthernetSegment_Esi_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_EsiPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_EsiPath extracts the value of the leaf Esi from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union.
func convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union{
		Metadata: md,
	}
	val := parent.Esi
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_EvpnTypes_EsiType{
		Metadata: md,
	}).SetVal(goStruct.GetEsiType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Get(t testing.TB) oc.E_EvpnTypes_EsiType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EsiType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EsiType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EsiType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EsiType {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EsiType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EsiType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_EsiTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EsiType) bool) *oc.E_EvpnTypes_EsiTypeWatcher {
	t.Helper()
	w := &oc.E_EvpnTypes_EsiTypeWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_EvpnTypes_EsiType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EsiType) bool) *oc.E_EvpnTypes_EsiTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_EvpnTypes_EsiType) *oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_EvpnTypes_EsiType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EsiType {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EsiType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EsiType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EsiType) bool) *oc.E_EvpnTypes_EsiTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi-type to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath extracts the value of the leaf EsiType from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EsiType.
func convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EsiType{
		Metadata: md,
	}
	val := parent.EsiType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/interface to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_NamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_NamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/name to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EthernetSegment_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Get(t testing.TB) oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EVPN_REDUNDANCY_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool) *oc.E_EvpnTypes_EVPN_REDUNDANCY_MODEWatcher {
	t.Helper()
	w := &oc.E_EvpnTypes_EVPN_REDUNDANCY_MODEWatcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool) *oc.E_EvpnTypes_EVPN_REDUNDANCY_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Await(t testing.TB, timeout time.Duration, val oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE) *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EVPN_REDUNDANCY_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE) bool) *oc.E_EvpnTypes_EVPN_REDUNDANCY_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/redundancy-mode to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath extracts the value of the leaf RedundancyMode from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE.
func convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE{
		Metadata: md,
	}
	val := parent.RedundancyMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Evpn_EthernetSegment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/subinterface to the batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool) *oc.NetworkInstance_Evpn_EvpnInstanceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstanceWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool) *oc.NetworkInstance_Evpn_EvpnInstanceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance) bool) *oc.NetworkInstance_Evpn_EvpnInstanceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstancePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance_BComponent)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_BComponentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_BComponentWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponentPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/b-component-name to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath extracts the value of the leaf BComponentName from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.BComponentName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/state/backbone-src-mac to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath extracts the value of the leaf BackboneSrcMac from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.BackboneSrcMac
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) bool) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/state/i-sid to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath extracts the value of the leaf ISid from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ISid
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENCAPSULATION
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	w := &oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	c := &oc.CollectionE_NetworkInstanceTypes_ENCAPSULATION{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION) bool) *oc.E_NetworkInstanceTypes_ENCAPSULATIONWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/encapsulation-type to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath extracts the value of the leaf EncapsulationType from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION.
func convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION{
		Metadata: md,
	}
	val := parent.EncapsulationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_EviPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_EviPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_EviPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_EviPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_EviPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_EviPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/evi to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_EviPath extracts the value of the leaf Evi from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_EviPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Evi
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath extracts the value of the leaf ExportRouteTarget from its parent oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice.
func convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ExportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice) bool) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath extracts the value of the leaf ImportRouteTarget from its parent oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice.
func convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ImportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-group to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath extracts the value of the leaf MulticastGroup from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/multicast-mask to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath extracts the value of the leaf MulticastMask from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastMask
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Get(t testing.TB) oc.E_EvpnInstance_ReplicationMode {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnInstance_ReplicationMode
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Get(t testing.TB) []oc.E_EvpnInstance_ReplicationMode {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnInstance_ReplicationMode
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnInstance_ReplicationMode {
	t.Helper()
	c := &oc.CollectionE_EvpnInstance_ReplicationMode{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnInstance_ReplicationMode) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_EvpnInstance_ReplicationMode) bool) *oc.E_EvpnInstance_ReplicationModeWatcher {
	t.Helper()
	w := &oc.E_EvpnInstance_ReplicationModeWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_EvpnInstance_ReplicationMode)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnInstance_ReplicationMode) bool) *oc.E_EvpnInstance_ReplicationModeWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Await(t testing.TB, timeout time.Duration, val oc.E_EvpnInstance_ReplicationMode) *oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_EvpnInstance_ReplicationMode) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnInstance_ReplicationMode {
	t.Helper()
	c := &oc.CollectionE_EvpnInstance_ReplicationMode{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnInstance_ReplicationMode) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnInstance_ReplicationMode) bool) *oc.E_EvpnInstance_ReplicationModeWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/replication-mode to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath extracts the value of the leaf ReplicationMode from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnInstance_ReplicationMode.
func convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	qv := &oc.QualifiedE_EvpnInstance_ReplicationMode{
		Metadata: md,
	}
	val := parent.ReplicationMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Get(t testing.TB) oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool) *oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_UnionWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool) *oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) bool) *oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath extracts the value of the leaf RouteDistinguisher from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union.
func convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union{
		Metadata: md,
	}
	val := parent.RouteDistinguisher
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Get(t testing.TB) oc.E_EvpnTypes_EVPN_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EVPN_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EVPN_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EVPN_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EVPN_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool) *oc.E_EvpnTypes_EVPN_TYPEWatcher {
	t.Helper()
	w := &oc.E_EvpnTypes_EVPN_TYPEWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_EvpnTypes_EVPN_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool) *oc.E_EvpnTypes_EVPN_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_EvpnTypes_EVPN_TYPE) *oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	c := &oc.CollectionE_EvpnTypes_EVPN_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_EvpnTypes_EVPN_TYPE) bool) *oc.E_EvpnTypes_EVPN_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/service-type to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath extracts the value of the leaf ServiceType from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EVPN_TYPE.
func convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EVPN_TYPE{
		Metadata: md,
	}
	val := parent.ServiceType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_VxlanPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool) *oc.NetworkInstance_Evpn_EvpnInstance_VxlanWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_VxlanWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool) *oc.NetworkInstance_Evpn_EvpnInstance_VxlanWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_VxlanPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan) bool) *oc.NetworkInstance_Evpn_EvpnInstance_VxlanWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_VxlanPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfaceWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", gs, queryPath, false, false)
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) bool) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/interface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/state/subinterface to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", gs, queryPath, true, false)
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/state/host-reachability-bgp to the batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath extracts the value of the leaf HostReachabilityBgp from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HostReachabilityBgp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}
